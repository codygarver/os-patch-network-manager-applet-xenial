From: Mathieu Trudel-Lapierre <mathieu.trudel-lapierre@canonical.com>
Subject: Implement conditional support for libappindicator

To get better integration with Unity (and actually have nm-applet show up at
all with Unity / compiz), implement drawing the applet using libappindicator.

To play well with others, this patch actually implements libappindicator
conditionally to running configure with --enable-indicator.

Index: network-manager-applet-1.0.4/configure.ac
===================================================================
--- network-manager-applet-1.0.4.orig/configure.ac
+++ network-manager-applet-1.0.4/configure.ac
@@ -145,6 +145,14 @@ case "${with_bluetooth}" in
 		;;
 esac
 
+AC_ARG_ENABLE([indicator],
+[  --enable-appindicator  Enables using libappindicator to draw the applet
+                          on the screen, instead of the standard status icons.],
+[
+	PKG_CHECK_MODULES(APPINDICATOR, appindicator3-0.1)
+	AC_DEFINE([ENABLE_INDICATOR], 1, [Enable using libappindicator])
+])
+
 AM_CONDITIONAL(HAVE_GBT, test x"$have_gbt" = "xyes")
 
 dnl ModemManager1 with libmm-glib
Index: network-manager-applet-1.0.4/src/Makefile.am
===================================================================
--- network-manager-applet-1.0.4.orig/src/Makefile.am
+++ network-manager-applet-1.0.4/src/Makefile.am
@@ -7,6 +7,7 @@ nm_applet_CPPFLAGS = \
 	$(NMA_CFLAGS) \
 	$(LIBSECRET_CFLAGS) \
 	$(NOTIFY_CFLAGS) \
+	$(APPINDICATOR_CFLAGS) \
 	-DNM_VERSION_MIN_REQUIRED=NM_VERSION_1_0 \
 	-DNM_VERSION_MAX_ALLOWED=NM_VERSION_1_0 \
 	-DICONDIR=\""$(datadir)/icons"\"						\
@@ -78,6 +79,7 @@ nm_applet_LDADD = \
 	$(NMA_LIBS) \
 	$(LIBSECRET_LIBS) \
 	$(NOTIFY_LIBS) \
+	$(APPINDICATOR_LIBS) \
 	${top_builddir}/src/marshallers/libmarshallers.la \
 	${top_builddir}/src/utils/libutils.la \
 	${top_builddir}/src/wireless-security/libwireless-security.la \
Index: network-manager-applet-1.0.4/src/applet-device-bt.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet-device-bt.c
+++ network-manager-applet-1.0.4/src/applet-device-bt.c
@@ -70,7 +70,9 @@ bt_add_menu_item (NMDevice *device,
 
 	item = applet_menu_item_create_device_item_helper (device, applet, text);
 
+#ifndef ENABLE_INDICATOR
 	gtk_widget_set_sensitive (item, FALSE);
+#endif
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 	gtk_widget_show (item);
 
Index: network-manager-applet-1.0.4/src/applet-device-cdma.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet-device-cdma.c
+++ network-manager-applet-1.0.4/src/applet-device-cdma.c
@@ -235,8 +235,12 @@ cdma_add_menu_item (NMDevice *device,
 {
 	CdmaDeviceInfo *info;
 	char *text;
+	const char *icon_name;
 	GtkWidget *item;
 	GSList *iter;
+#ifdef ENABLE_INDICATOR
+	GtkWidget *signal_icon;
+#endif
 
 	info = g_object_get_data (G_OBJECT (device), "devinfo");
 
@@ -250,7 +254,9 @@ cdma_add_menu_item (NMDevice *device,
 	}
 
 	item = applet_menu_item_create_device_item_helper (device, applet, text);
+#ifndef ENABLE_INDICATOR
 	gtk_widget_set_sensitive (item, FALSE);
+#endif
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 	gtk_widget_show (item);
 	g_free (text);
@@ -262,6 +268,7 @@ cdma_add_menu_item (NMDevice *device,
 		s_con = nm_connection_get_setting_connection (active);
 		g_assert (s_con);
 
+#ifndef ENABLE_INDICATOR
 		item = nm_mb_menu_item_new (nm_setting_connection_get_id (s_con),
 		                            info->quality_valid ? info->quality : 0,
 		                            info->provider_name,
@@ -270,6 +277,19 @@ cdma_add_menu_item (NMDevice *device,
 		                            cdma_state_to_mb_state (info),
 		                            info->modem_enabled,
 		                            applet);
+#else
+		text = mobile_helper_get_connection_label (nm_setting_connection_get_id (s_con),
+		                                           info->provider_name,
+		                                           cdma_act_to_mb_act (info),
+		                                           cdma_state_to_mb_state (info));
+		item = gtk_image_menu_item_new_with_label (text);
+		g_free (text);
+		icon_name = mobile_helper_get_quality_icon_name (info->quality_valid ?
+		                                                 info->quality : 0);
+		signal_icon = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_LARGE_TOOLBAR);
+		gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), signal_icon);
+		gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
+#endif
 		gtk_widget_set_sensitive (GTK_WIDGET (item), TRUE);
 		add_connection_item (device, active, item, menu, applet);
 	}
@@ -283,6 +303,7 @@ cdma_add_menu_item (NMDevice *device,
 		}
 	} else {
 		/* Otherwise show idle registration state or disabled */
+#ifndef ENABLE_INDICATOR
 		item = nm_mb_menu_item_new (NULL,
 		                            info->quality_valid ? info->quality : 0,
 		                            info->provider_name,
@@ -291,6 +312,19 @@ cdma_add_menu_item (NMDevice *device,
 		                            cdma_state_to_mb_state (info),
 		                            info->modem_enabled,
 		                            applet);
+#else
+		text = mobile_helper_get_connection_label (NULL,
+		                                           info->provider_name,
+		                                           cdma_act_to_mb_act (info),
+		                                           cdma_state_to_mb_state (info));
+		item = gtk_image_menu_item_new_with_label (text);
+		g_free (text);
+		icon_name = mobile_helper_get_quality_icon_name (info->quality_valid ?
+		                                                 info->quality : 0);
+		signal_icon = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_LARGE_TOOLBAR);
+		gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), signal_icon);
+		gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
+#endif
 		gtk_widget_set_sensitive (GTK_WIDGET (item), FALSE);
 		gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 	}
@@ -596,6 +630,9 @@ reg_state_changed_cb (DBusGProxy *proxy,
 	update_registration_state (info, cdma1x_state, evdo_state);
 	info->skip_reg_poll = TRUE;
 	applet_schedule_update_icon (info->applet);
+#ifdef ENABLE_INDICATOR
+	applet_schedule_update_menu (info->applet);
+#endif /* ENABLE_INDICATOR */
 }
 
 static void
Index: network-manager-applet-1.0.4/src/applet-device-gsm.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet-device-gsm.c
+++ network-manager-applet-1.0.4/src/applet-device-gsm.c
@@ -44,6 +44,7 @@
 #include "applet.h"
 #include "applet-device-gsm.h"
 #include "utils.h"
+#include "mobile-helpers.h"
 #include "applet-dialogs.h"
 #include "mb-menu-item.h"
 #include "nma-marshal.h"
@@ -291,8 +292,12 @@ gsm_add_menu_item (NMDevice *device,
 {
 	GsmDeviceInfo *info;
 	char *text;
+	const char *icon_name;
 	GtkWidget *item;
 	GSList *iter;
+#ifdef ENABLE_INDICATOR
+	GtkWidget *signal_icon;
+#endif
 
 	info = g_object_get_data (G_OBJECT (device), "devinfo");
 
@@ -306,7 +311,9 @@ gsm_add_menu_item (NMDevice *device,
 	}
 
 	item = applet_menu_item_create_device_item_helper (device, applet, text);
+#ifndef ENABLE_INDICATOR
 	gtk_widget_set_sensitive (item, FALSE);
+#endif
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 	gtk_widget_show (item);
 	g_free (text);
@@ -318,6 +325,7 @@ gsm_add_menu_item (NMDevice *device,
 		s_con = nm_connection_get_setting_connection (active);
 		g_assert (s_con);
 
+#ifndef ENABLE_INDICATOR
 		item = nm_mb_menu_item_new (nm_setting_connection_get_id (s_con),
 		                            info->quality_valid ? info->quality : 0,
 		                            info->op_name,
@@ -326,6 +334,19 @@ gsm_add_menu_item (NMDevice *device,
 		                            gsm_state_to_mb_state (info),
 		                            info->modem_enabled,
 		                            applet);
+#else
+		text = mobile_helper_get_connection_label (nm_setting_connection_get_id (s_con),
+		                                           info->op_name,
+		                                           gsm_act_to_mb_act (info),
+		                                           gsm_state_to_mb_state (info));
+		item = gtk_image_menu_item_new_with_label (text);
+		g_free (text);
+		icon_name = mobile_helper_get_quality_icon_name (info->quality_valid ?
+		                                                 info->quality : 0);
+		signal_icon = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_LARGE_TOOLBAR);
+		gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), signal_icon);
+		gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
+#endif
 		gtk_widget_set_sensitive (GTK_WIDGET (item), TRUE);
 		add_connection_item (device, active, item, menu, applet);
 	}
@@ -339,6 +360,7 @@ gsm_add_menu_item (NMDevice *device,
 		}
 	} else {
 		/* Otherwise show idle registration state or disabled */
+#ifndef ENABLE_INDICATOR
 		item = nm_mb_menu_item_new (NULL,
 		                            info->quality_valid ? info->quality : 0,
 		                            info->op_name,
@@ -347,6 +369,21 @@ gsm_add_menu_item (NMDevice *device,
 		                            gsm_state_to_mb_state (info),
 		                            info->modem_enabled,
 		                            applet);
+#else
+		text = mobile_helper_get_connection_label (NULL,
+		                                           info->op_name,
+		                                           gsm_act_to_mb_act (info),
+		                                           gsm_state_to_mb_state (info));
+		item = gtk_image_menu_item_new_with_label (text);
+		g_free (text);
+		icon_name = mobile_helper_get_quality_icon_name (info->quality_valid ?
+		                                                 info->quality : 0);
+		signal_icon = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_LARGE_TOOLBAR);
+		gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), signal_icon);
+		gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
+		gtk_widget_set_sensitive (item, FALSE);
+#endif
+
 		gtk_widget_set_sensitive (GTK_WIDGET (item), FALSE);
 		gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 	}
@@ -1035,6 +1072,10 @@ reg_info_changed_cb (DBusGProxy *proxy,
 	                                                        op_name,
 	                                                        info->op_code);
 	info->skip_reg_poll = TRUE;
+
+#ifdef ENABLE_INDICATOR
+	applet_schedule_update_menu (info->applet);
+#endif /* ENABLE_INDICATOR */
 }
 
 static void
Index: network-manager-applet-1.0.4/src/applet-device-wifi.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet-device-wifi.c
+++ network-manager-applet-1.0.4/src/applet-device-wifi.c
@@ -31,6 +31,7 @@
 
 #include <glib/gi18n.h>
 #include <gtk/gtk.h>
+#include <atk/atk.h>
 
 #include <nm-device.h>
 #include <nm-access-point.h>
@@ -306,6 +307,135 @@ is_blacklisted_ssid (const GByteArray *s
 	return is_ssid_in_list (ssid, blacklisted_ssids);
 }
 
+#ifdef ENABLE_INDICATOR
+static void
+clear_dupes_list (GSList *list)
+{
+	g_slist_foreach (list, (GFunc) g_free, NULL);
+	g_slist_free (list);
+}
+
+static gboolean
+get_ap_is_encrypted (NMAccessPoint *ap)
+{
+	guint32 ap_flags, ap_wpa, ap_rsn;
+
+	ap_flags = nm_access_point_get_flags (ap);
+	ap_wpa = nm_access_point_get_wpa_flags (ap);
+	ap_rsn = nm_access_point_get_rsn_flags (ap);
+
+	if ((ap_flags & NM_802_11_AP_FLAGS_PRIVACY) || ap_wpa || ap_rsn)
+		return TRUE;
+
+	return FALSE;
+}
+
+static void
+ap_menu_item_set_sensitive (GtkWidget *item, NMAccessPoint *ap, guint32 dev_caps)
+{
+	gboolean is_adhoc = FALSE;
+	guint32 ap_flags, ap_wpa, ap_rsn;
+
+	ap_flags = nm_access_point_get_flags (ap);
+	ap_wpa = nm_access_point_get_wpa_flags (ap);
+	ap_rsn = nm_access_point_get_rsn_flags (ap);
+
+	if (nm_access_point_get_mode (ap) == NM_802_11_MODE_ADHOC)
+		is_adhoc = TRUE;
+
+	/* Don't enable the menu item the device can't even connect to the AP */
+	if (   !nm_utils_security_valid (NMU_SEC_NONE, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_STATIC_WEP, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_LEAP, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_DYNAMIC_WEP, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_WPA_PSK, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_WPA2_PSK, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_WPA_ENTERPRISE, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)
+		&& !nm_utils_security_valid (NMU_SEC_WPA2_ENTERPRISE, dev_caps, TRUE, is_adhoc, ap_flags, ap_wpa, ap_rsn)) {
+		gtk_widget_set_sensitive (GTK_WIDGET (item), FALSE);
+	}
+}
+
+static gchar *
+get_best_icon_name_for_ap (NMAccessPoint *ap, gboolean need_sec, gboolean encrypted)
+{
+	GString *icon_name = NULL;
+	gchar *tmp = NULL;
+	guint32 strength;
+
+	g_return_val_if_fail (NM_IS_ACCESS_POINT (ap), NULL);
+
+	strength = nm_access_point_get_strength (ap);
+	strength = CLAMP (strength, 0, 100);
+
+	icon_name = g_string_new ("");
+	if (strength > 80)
+		icon_name = g_string_assign (icon_name, "nm-signal-100");
+	else if (strength > 55)
+		icon_name = g_string_assign (icon_name, "nm-signal-75");
+	else if (strength > 30)
+		icon_name = g_string_assign (icon_name, "nm-signal-50");
+	else if (strength > 5)
+		icon_name = g_string_assign (icon_name, "nm-signal-25");
+	else
+		icon_name = g_string_assign (icon_name, "nm-signal-00");
+
+	if (nm_access_point_get_mode (ap) == NM_802_11_MODE_ADHOC) {
+		icon_name = g_string_assign (icon_name, "nm-adhoc");
+		goto out;
+	}
+
+	if (need_sec && encrypted)
+		icon_name = g_string_append (icon_name, "-secure");
+
+out:
+	tmp = icon_name->str;
+	g_string_free (icon_name, FALSE);
+
+	return tmp;
+}
+
+static void
+set_menu_item_accessible_desc (NMAccessPoint *ap,
+                               GtkMenuItem *item,
+                               gboolean is_encrypted)
+{
+	guint32 strength;
+	gchar *ssid = NULL;
+	GString *icon_desc = NULL;
+
+	g_return_if_fail (NM_IS_ACCESS_POINT (ap));
+
+	strength = nm_access_point_get_strength (ap);
+	strength = CLAMP (strength, 0, 100);
+
+	ssid = g_strdup (gtk_menu_item_get_label (item));
+
+	if (ssid == NULL)
+		return;
+
+	icon_desc = g_string_new ("");
+	g_string_append_printf (icon_desc, "%s: ", ssid);
+
+	if (nm_access_point_get_mode (ap) == NM_802_11_MODE_ADHOC) {
+		icon_desc = g_string_append (icon_desc, _("ad-hoc"));
+		goto out;
+	}
+
+	g_string_append_printf (icon_desc, "%d%%", strength);
+
+	if (is_encrypted) {
+		icon_desc = g_string_append (icon_desc, ", ");
+		icon_desc = g_string_append (icon_desc, _("secure."));
+	}
+
+out:
+	atk_object_set_name (gtk_widget_get_accessible (GTK_WIDGET (item)), icon_desc->str);
+	g_free (ssid);
+	g_string_free (icon_desc, TRUE);
+}
+#endif
+
 static void
 clamp_ap_to_bssid (NMAccessPoint *ap, NMSettingWireless *s_wifi)
 {
@@ -500,7 +630,11 @@ wifi_menu_item_activate (GtkMenuItem *it
 
 struct dup_data {
 	NMDevice *device;
+#ifndef ENABLE_INDICATOR
 	NMNetworkMenuItem *found;
+#else
+	GtkWidget *found;
+#endif
 	char *hash;
 };
 
@@ -516,19 +650,34 @@ find_duplicate (gpointer d, gpointer use
 	g_return_if_fail (data);
 	g_return_if_fail (data->hash);
 
+#ifndef ENABLE_INDICATOR
 	if (data->found || !NM_IS_NETWORK_MENU_ITEM (widget))
 		return;
+#else
+	if (data->found || !GTK_IS_IMAGE_MENU_ITEM (widget))
+		return;
+#endif
 
 	device = g_object_get_data (G_OBJECT (widget), "device");
 	if (NM_DEVICE (device) != data->device)
 		return;
 
+#ifndef ENABLE_INDICATOR
 	hash = nm_network_menu_item_get_hash (NM_NETWORK_MENU_ITEM (widget));
 	if (hash && (strcmp (hash, data->hash) == 0))
 		data->found = NM_NETWORK_MENU_ITEM (widget);
+#else
+	hash = g_object_get_data (G_OBJECT (widget), "hash");
+	if (hash && (strcmp (hash, data->hash) == 0))
+		data->found = widget;
+#endif /* ENABLE_INDICATOR */
 }
 
+#ifndef ENABLE_INDICATOR
 static NMNetworkMenuItem *
+#else
+static GtkImageMenuItem *
+#endif
 create_new_ap_item (NMDeviceWifi *device,
                     NMAccessPoint *ap,
                     struct dup_data *dup_data,
@@ -537,7 +686,16 @@ create_new_ap_item (NMDeviceWifi *device
 {
 	WifiMenuItemInfo *info;
 	GSList *iter;
+#ifndef ENABLE_INDICATOR
 	NMNetworkMenuItem *item = NULL;
+#else
+	GtkImageMenuItem *item = NULL;
+	char *text, *best_icon_name;
+	const char *path;
+	GtkWidget *icon_image;
+	gboolean encrypted, ad_hoc;
+	GSList *dupes = NULL;
+#endif /* ENABLE_INDICATOR */
 	GSList *dev_connections = NULL;
 	GSList *ap_connections = NULL;
 	const GByteArray *ssid;
@@ -548,17 +706,50 @@ create_new_ap_item (NMDeviceWifi *device
 	g_slist_free (dev_connections);
 	dev_connections = NULL;
 
+	ssid = nm_access_point_get_ssid (ap);
+	dev_caps = nm_device_wifi_get_capabilities (device);
+
+#ifndef ENABLE_INDICATOR
 	item = NM_NETWORK_MENU_ITEM (nm_network_menu_item_new (dup_data->hash,
 	                                                       !!g_slist_length (ap_connections)));
 	gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
 
-	ssid = nm_access_point_get_ssid (ap);
 	nm_network_menu_item_set_ssid (item, (GByteArray *) ssid);
 
-	dev_caps = nm_device_wifi_get_capabilities (device);
 	nm_network_menu_item_set_detail (item, ap, nma_icon_check_and_load ("nm-adhoc", applet), dev_caps);
 	nm_network_menu_item_best_strength (item, nm_access_point_get_strength (ap), applet);
 	nm_network_menu_item_add_dupe (item, ap);
+#else
+	text = nm_utils_ssid_to_utf8 (ssid);
+	if (!text) {
+		// Avoid any cases where the SSID could possibly end up undefined.
+		text = g_strdup ("<unknown>");
+	}
+	item = GTK_IMAGE_MENU_ITEM (gtk_image_menu_item_new_with_label (text));
+	g_free (text);
+
+	encrypted = get_ap_is_encrypted (ap);
+	ad_hoc = nm_access_point_get_mode (ap) == NM_802_11_MODE_ADHOC;
+
+	best_icon_name = get_best_icon_name_for_ap (ap, TRUE, encrypted);
+	icon_image = gtk_image_new_from_icon_name (best_icon_name, GTK_ICON_SIZE_LARGE_TOOLBAR);
+	g_free (best_icon_name);
+
+	gtk_image_menu_item_set_image (item, icon_image);
+	gtk_image_menu_item_set_always_show_image (item, TRUE);
+
+	path = nm_object_get_path (NM_OBJECT (ap));
+	dupes = g_slist_append (dupes, g_strdup (path));
+	g_object_set_data_full (G_OBJECT (item), "dupes", (gpointer) dupes, (GDestroyNotify) clear_dupes_list);
+	g_object_set_data (G_OBJECT (item), "encrypted", (gpointer) encrypted);
+	g_object_set_data (G_OBJECT (item), "ad-hoc", (gpointer) ad_hoc);
+	g_object_set_data (G_OBJECT (item), "hash", (gpointer) dup_data->hash);
+	g_object_set_data (G_OBJECT (item), "has_connections", (gpointer) !!g_slist_length (ap_connections));
+
+	set_menu_item_accessible_desc (ap, GTK_MENU_ITEM (item), encrypted);
+
+	ap_menu_item_set_sensitive (GTK_WIDGET (item), ap, dev_caps);
+#endif /* ENABLE_INDICATOR */
 
 	g_object_set_data (G_OBJECT (item), "device", NM_DEVICE (device));
 
@@ -616,7 +807,11 @@ create_new_ap_item (NMDeviceWifi *device
 	return item;
 }
 
+#ifndef ENABLE_INDICATOR
 static NMNetworkMenuItem *
+#else
+static GtkImageMenuItem *
+#endif /* ENABLE_INDICATOR */
 get_menu_item_for_ap (NMDeviceWifi *device,
                       NMAccessPoint *ap,
                       GSList *connections,
@@ -640,14 +835,32 @@ get_menu_item_for_ap (NMDeviceWifi *devi
 	 */
 	dup_data.found = NULL;
 	dup_data.hash = g_object_get_data (G_OBJECT (ap), "hash");
+#ifndef ENABLE_INDICATOR
 	g_return_val_if_fail (dup_data.hash != NULL, NULL);
+#else
+	/* heh, not much choice here, otherwise on startup we get tons of errors
+	 * because g_return_val_if_fail prints assertion errors.
+	 */
+	if (dup_data.hash == NULL)
+		return NULL;
+#endif
 
 	dup_data.device = NM_DEVICE (device);
 	g_slist_foreach (menu_list, find_duplicate, &dup_data);
 
 	if (dup_data.found) {
+#ifndef ENABLE_INDICATOR
 		nm_network_menu_item_best_strength (dup_data.found, nm_access_point_get_strength (ap), applet);
 		nm_network_menu_item_add_dupe (dup_data.found, ap);
+#else
+		GSList *dupes = NULL;
+		const char *path;
+
+		dupes = g_object_steal_data (G_OBJECT (dup_data.found), "dupes");
+		path = nm_object_get_path (NM_OBJECT (ap));
+		dupes = g_slist_prepend (dupes, g_strdup (path));
+		g_object_set_data_full (G_OBJECT (dup_data.found), "dupes", (gpointer) dupes, (GDestroyNotify) clear_dupes_list);
+#endif
 		return NULL;
 	}
 
@@ -657,6 +870,7 @@ get_menu_item_for_ap (NMDeviceWifi *devi
 static gint
 sort_by_name (gconstpointer tmpa, gconstpointer tmpb)
 {
+#ifndef ENABLE_INDICATOR
 	NMNetworkMenuItem *a = NM_NETWORK_MENU_ITEM (tmpa);
 	NMNetworkMenuItem *b = NM_NETWORK_MENU_ITEM (tmpb);
 	const char *a_ssid, *b_ssid;
@@ -693,6 +907,44 @@ sort_by_name (gconstpointer tmpa, gconst
 		return -1;
 
 	return 0;
+#else
+	GtkImageMenuItem *a = GTK_IMAGE_MENU_ITEM (tmpa);
+	GtkImageMenuItem *b = GTK_IMAGE_MENU_ITEM (tmpb);
+	const char *a_ssid, *b_ssid;
+	gboolean a_adhoc, b_adhoc;
+	int i;
+
+	if (a && !b)
+		return 1;
+	else if (!a && b)
+		return -1;
+	else if (a == b)
+		return 0;
+
+	a_ssid = gtk_menu_item_get_label (GTK_MENU_ITEM (a));
+	b_ssid = gtk_menu_item_get_label (GTK_MENU_ITEM (b));
+
+	if (a_ssid && !b_ssid)
+		return 1;
+	if (b_ssid && !a_ssid)
+		return -1;
+
+	if (a_ssid && b_ssid) {
+		i = g_ascii_strcasecmp (a_ssid, b_ssid);
+		if (i != 0)
+			return i;
+	}
+
+	/* If the names are the same, sort infrastructure APs first */
+	a_adhoc = g_object_get_data (G_OBJECT (a), "ad-hoc");
+	b_adhoc = g_object_get_data (G_OBJECT (b), "ad-hoc");
+	if (a_adhoc && !b_adhoc)
+		return 1;
+	else if (!a_adhoc && b_adhoc)
+		return -1;
+
+	return 0;
+#endif /* ENABLE_INDICATOR */
 }
 
 /* Sort menu items for the top-level menu:
@@ -704,6 +956,7 @@ sort_by_name (gconstpointer tmpa, gconst
 static gint
 sort_toplevel (gconstpointer tmpa, gconstpointer tmpb)
 {
+#ifndef ENABLE_INDICATOR
 	NMNetworkMenuItem *a = NM_NETWORK_MENU_ITEM (tmpa);
 	NMNetworkMenuItem *b = NM_NETWORK_MENU_ITEM (tmpb);
 	gboolean a_fave, b_fave;
@@ -738,6 +991,42 @@ sort_toplevel (gconstpointer tmpa, gcons
 	 * both are unencrypted) just sort by name.
 	 */
 	return sort_by_name (a, b);
+#else
+	GtkImageMenuItem *a = GTK_IMAGE_MENU_ITEM (tmpa);
+	GtkImageMenuItem *b = GTK_IMAGE_MENU_ITEM (tmpb);
+	gboolean a_fave, b_fave;
+
+	if (a && !b)
+		return 1;
+	else if (!a && b)
+		return -1;
+	else if (a == b)
+		return 0;
+
+	a_fave = g_object_get_data (G_OBJECT (a), "has_connections");
+	b_fave = g_object_get_data (G_OBJECT (b), "has_connections");
+
+	/* Items with a saved connection first */
+	if (a_fave && !b_fave)
+		return -1;
+	else if (!a_fave && b_fave)
+		return 1;
+	else if (!a_fave && !b_fave) {
+		gboolean a_enc = g_object_get_data (G_OBJECT (a), "encrypted");
+		gboolean b_enc = g_object_get_data (G_OBJECT (b), "encrypted");
+
+		/* If neither item has a saved connection, sort by encryption */
+		if (a_enc && !b_enc)
+			return -1;
+		else if (!a_enc && b_enc)
+			return 1;
+	}
+
+	/* For all other cases (both have saved connections, both are encrypted, or
+	 * both are unencrypted) just sort by name.
+	 */
+	return sort_by_name (a, b);
+#endif /* ENABLE_INDICATOR */
 }
 
 static void
@@ -757,7 +1046,11 @@ wifi_add_menu_item (NMDevice *device,
 	gboolean wifi_enabled = TRUE;
 	gboolean wifi_hw_enabled = TRUE;
 	GSList *menu_items = NULL;  /* All menu items we'll be adding */
+#ifndef ENABLE_INDICATOR
 	NMNetworkMenuItem *item, *active_item = NULL;
+#else
+	GtkImageMenuItem *item, *active_item = NULL;
+#endif /* ENABLE_INDICATOR */
 	GtkWidget *widget;
 
 	wdev = NM_DEVICE_WIFI (device);
@@ -787,7 +1080,9 @@ wifi_add_menu_item (NMDevice *device,
 		if (active_ap) {
 			active_item = item = get_menu_item_for_ap (wdev, active_ap, connections, NULL, applet);
 			if (item) {
+#ifndef ENABLE_INDICATOR
 				nm_network_menu_item_set_active (item, TRUE);
+#endif
 				menu_items = g_slist_append (menu_items, item);
 
 				gtk_menu_shell_append (GTK_MENU_SHELL (menu), GTK_WIDGET (item));
@@ -1081,6 +1376,9 @@ access_point_added_cb (NMDeviceWifi *dev
 	                  applet);
 	
 	queue_avail_access_point_notification (NM_DEVICE (device));
+#ifdef ENABLE_INDICATOR
+	applet_schedule_update_menu (applet);
+#endif /* ENABLE_INDICATOR */
 }
 
 static void
@@ -1098,6 +1396,9 @@ access_point_removed_cb (NMDeviceWifi *d
 	if (old == ap) {
 		g_object_set_data (G_OBJECT (device), ACTIVE_AP_TAG, NULL);
 		applet_schedule_update_icon (applet);
+#ifdef ENABLE_INDICATOR
+		applet_schedule_update_menu (applet);
+#endif /* ENABLE_INDICATOR */
 	}
 }
 
Index: network-manager-applet-1.0.4/src/applet-device-ethernet.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet-device-ethernet.c
+++ network-manager-applet-1.0.4/src/applet-device-ethernet.c
@@ -112,7 +112,9 @@ ethernet_add_menu_item (NMDevice *device
  	if (nm_device_get_capabilities (device) & NM_DEVICE_CAP_CARRIER_DETECT)
 		carrier = nm_device_ethernet_get_carrier (NM_DEVICE_ETHERNET (device));
 
+#ifndef ENABLE_INDICATOR
 	gtk_widget_set_sensitive (item, FALSE);
+#endif
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), item);
 	gtk_widget_show (item);
 
Index: network-manager-applet-1.0.4/src/applet.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet.c
+++ network-manager-applet-1.0.4/src/applet.c
@@ -584,6 +584,8 @@ add_and_activate_cb (NMClient *client,
                      GError *error,
                      gpointer user_data)
 {
+	NMApplet *applet = NM_APPLET (user_data);
+
 	if (error) {
 		const char *text = _("Failed to add/activate connection");
 		char *err_text = g_strdup_printf ("(%d) %s", error->code,
@@ -594,7 +596,8 @@ add_and_activate_cb (NMClient *client,
 		g_free (err_text);
 	}
 
-	applet_schedule_update_icon (NM_APPLET (user_data));
+	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
 static void
@@ -628,6 +631,8 @@ applet_menu_item_activate_helper_new_con
 static void
 disconnect_cb (NMDevice *device, GError *error, gpointer user_data)
 {
+	NMApplet *applet = NM_APPLET (user_data);
+
 	if (error) {
 		const char *text = _("Device disconnect failed");
 		char *err_text = g_strdup_printf ("(%d) %s", error->code,
@@ -637,6 +642,9 @@ disconnect_cb (NMDevice *device, GError
 		utils_show_error_dialog (_("Disconnect failure"), text, err_text, FALSE, NULL);
 		g_free (err_text);
 	}
+
+	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
 void
@@ -645,7 +653,7 @@ applet_menu_item_disconnect_helper (NMDe
 {
 	g_return_if_fail (NM_IS_DEVICE (device));
 
-	nm_device_disconnect (device, disconnect_cb, NULL);
+	nm_device_disconnect (device, disconnect_cb, applet);
 }
 
 static void
@@ -715,10 +723,13 @@ applet_menu_item_add_complex_separator_h
                                                NMApplet *applet,
                                                const gchar* label)
 {
-	GtkWidget *menu_item = gtk_image_menu_item_new ();
+	GtkWidget *menu_item = NULL;
+#ifndef ENABLE_INDICATOR
 	GtkWidget *box = gtk_box_new (GTK_ORIENTATION_HORIZONTAL, 0);
 	GtkWidget *xlabel = NULL;
 
+	menu_item = gtk_image_menu_item_new ();
+
 	if (label) {
 		xlabel = gtk_label_new (NULL);
 		gtk_label_set_markup (GTK_LABEL (xlabel), label);
@@ -734,6 +745,11 @@ applet_menu_item_add_complex_separator_h
 	              "sensitive", FALSE,
 	              NULL);
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), menu_item);
+#else
+	menu_item = gtk_separator_menu_item_new ();
+	gtk_menu_shell_append (GTK_MENU_SHELL (menu), menu_item);
+#endif /* ENABLE_INDICATOR */
+
 }
 
 GtkWidget *
@@ -743,10 +759,13 @@ applet_new_menu_item_helper (NMConnectio
 {
 	GtkWidget *item;
 	NMSettingConnection *s_con;
+#ifndef ENABLE_INDICATOR
 	char *markup;
 	GtkWidget *label;
+#endif /* ENABLE_INDICATOR */
 
 	s_con = nm_connection_get_setting_connection (connection);
+#ifndef ENABLE_INDICATOR
 	item = gtk_image_menu_item_new_with_label ("");
 	if (add_active && (active == connection)) {
 		/* Pure evil */
@@ -759,9 +778,13 @@ applet_new_menu_item_helper (NMConnectio
 		gtk_menu_item_set_label (GTK_MENU_ITEM (item), nm_setting_connection_get_id (s_con));
 
 	gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
+#else
+	item = gtk_menu_item_new_with_label (nm_setting_connection_get_id (s_con));
+#endif /* ENABLE_INDICATOR */
 	return item;
 }
 
+#ifndef ENABLE_INDICATOR
 #define TITLE_TEXT_R ((double) 0x5e / 255.0 )
 #define TITLE_TEXT_G ((double) 0x5e / 255.0 )
 #define TITLE_TEXT_B ((double) 0x5e / 255.0 )
@@ -826,6 +849,8 @@ menu_title_item_draw (GtkWidget *widget,
 	return TRUE;
 }
 
+#endif /* ENABLE_INDICATOR */
+
 GtkWidget *
 applet_menu_item_create_device_item_helper (NMDevice *device,
                                             NMApplet *applet,
@@ -835,7 +860,9 @@ applet_menu_item_create_device_item_help
 
 	item = gtk_menu_item_new_with_label (text);
 	gtk_widget_set_sensitive (item, FALSE);
+#ifndef ENABLE_INDICATOR
 	g_signal_connect (item, "draw", G_CALLBACK (menu_title_item_draw), NULL);
+#endif /* ENABLE_INDICATOR */
 	return item;
 }
 
@@ -882,7 +909,12 @@ applet_do_notify (NMApplet *applet,
 	g_return_if_fail (summary != NULL);
 	g_return_if_fail (message != NULL);
 
+#ifndef ENABLE_INDICATOR
 	if (!gtk_status_icon_is_embedded (applet->status_icon))
+#else
+	if (!gtk_status_icon_is_embedded (applet->status_icon) &&
+	    app_indicator_get_status (applet->app_indicator) == APP_INDICATOR_STATUS_PASSIVE)
+#endif /* ENABLE_INDICATOR */
 		return;
 
 	/* if we're not acting as a secret agent, don't notify either */
@@ -1171,6 +1203,7 @@ vpn_connection_state_changed (NMVPNConne
 		clear_animation_timeout (applet);
 
 	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
 static const char *
@@ -1226,10 +1259,13 @@ activate_vpn_cb (NMClient *client,
 	}
 
 	applet_schedule_update_icon (info->applet);
+	applet_schedule_update_menu (info->applet);
 	g_free (info->vpn_name);
 	g_free (info);
 }
 
+static void nma_menu_disconnect_vpn_item_activate (GtkMenuItem *item, gpointer user_data);
+
 static void
 nma_menu_vpn_item_clicked (GtkMenuItem *item, gpointer user_data)
 {
@@ -1252,9 +1288,14 @@ nma_menu_vpn_item_clicked (GtkMenuItem *
 		return;
 	}
 
-	if (applet_get_active_for_connection (applet, connection))
+	if (applet_get_active_for_connection (applet, connection)) {
+#ifndef ENABLE_INDICATOR
 		/* Connection already active; do nothing */
+#else
+		nma_menu_disconnect_vpn_item_activate (item, applet);
+#endif /* ENABLE_INDICATOR */
 		return;
+	}
 
 	s_con = nm_connection_get_setting_connection (connection);
 	info = g_malloc0 (sizeof (VPNActivateInfo));
@@ -1621,6 +1662,7 @@ add_device_items (NMDeviceType type, con
 		active = applet_find_active_connection_for_device (device, applet, NULL);
 
 		dclass->add_menu_item (device, n_devices > 1, connections, active, menu, applet);
+		nma_menu_add_separator_item (menu);
 
 		g_slist_free (connections);
 	}
@@ -1703,6 +1745,7 @@ add_virtual_items (const char *type, con
 
 		dclass = get_device_class_from_connection (connection, applet);
 		dclass->add_menu_item (device, n_devices > 1, iface_connections, active, menu, applet);
+		nma_menu_add_separator_item (menu);
 
 		g_slist_free (iface_connections);
 	}
@@ -1811,13 +1854,20 @@ nma_menu_add_vpn_submenu (GtkWidget *men
 		NMConnection *connection = NM_CONNECTION (iter->data);
 		NMActiveConnection *active;
 		const char *name;
+#ifndef ENABLE_INDICATOR
 		GtkWidget *image;
+#endif /* ENABLE_INDICATOR */
 		NMState state;
 
 		name = get_connection_id (connection);
 
+#ifndef ENABLE_INDICATOR
 		item = GTK_MENU_ITEM (gtk_image_menu_item_new_with_label (name));
 		gtk_image_menu_item_set_always_show_image(GTK_IMAGE_MENU_ITEM(item), TRUE);
+#else
+		item = GTK_MENU_ITEM (gtk_check_menu_item_new_with_label (name));
+		gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM(item), FALSE);
+#endif /* ENABLE_INDICATOR */
 
 		/* If no VPN connections are active, draw all menu items enabled. If
 		 * >= 1 VPN connections are active, only the active VPN menu item is
@@ -1836,8 +1886,12 @@ nma_menu_add_vpn_submenu (GtkWidget *men
 			gtk_widget_set_sensitive (GTK_WIDGET (item), FALSE);
 
 		if (active) {
+#ifndef ENABLE_INDICATOR
 			image = gtk_image_new_from_stock (GTK_STOCK_CONNECT, GTK_ICON_SIZE_MENU);
 			gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), image);
+#else
+			gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM(item), TRUE);
+#endif /* ENABLE_INDICATOR */
 		}
 
 		g_object_set_data_full (G_OBJECT (item), "connection", 
@@ -1911,6 +1965,7 @@ nma_set_networking_enabled_cb (GtkWidget
 }
 
 
+#ifndef ENABLE_INDICATOR
 static void
 nma_set_notifications_enabled_cb (GtkWidget *widget, NMApplet *applet)
 {
@@ -1933,6 +1988,7 @@ nma_set_notifications_enabled_cb (GtkWid
 	                        PREF_SUPPRESS_WIFI_NETWORKS_AVAILABLE,
 	                        !state);
 }
+#endif /* ENABLE_INDICATOR */
 
 static gboolean
 has_usable_wifi (NMApplet *applet)
@@ -2042,7 +2098,9 @@ nma_context_menu_update (NMApplet *apple
 	gboolean wifi_hw_enabled;
 	gboolean wwan_hw_enabled;
 	gboolean wimax_hw_enabled;
+#ifndef ENABLE_INDICATOR
 	gboolean notifications_enabled = TRUE;
+#endif /* ENABLE_INDICATOR */
 	gboolean sensitive = FALSE;
 
 	state = nm_client_get_state (applet->nm_client);
@@ -2102,6 +2160,7 @@ nma_context_menu_update (NMApplet *apple
 	gtk_widget_set_sensitive (GTK_WIDGET (applet->wimax_enabled_item),
 	                          wimax_hw_enabled && is_permission_yes (applet, NM_CLIENT_PERMISSION_ENABLE_DISABLE_WIMAX));
 
+#ifndef ENABLE_INDICATOR
 	/* Enabled notifications */
 	g_signal_handler_block (G_OBJECT (applet->notifications_enabled_item),
 	                        applet->notifications_enabled_toggled_id);
@@ -2113,6 +2172,7 @@ nma_context_menu_update (NMApplet *apple
 	gtk_check_menu_item_set_active (GTK_CHECK_MENU_ITEM (applet->notifications_enabled_item), notifications_enabled);
 	g_signal_handler_unblock (G_OBJECT (applet->notifications_enabled_item),
 	                          applet->notifications_enabled_toggled_id);
+#endif /* ENABLE_INDICATOR */
 
 	/* Don't show wifi-specific stuff if wifi is off */
 	if (state != NM_STATE_ASLEEP) {
@@ -2185,16 +2245,20 @@ applet_connection_info_cb (NMApplet *app
  * Generate the contextual popup menu.
  *
  */
-static GtkWidget *nma_context_menu_create (NMApplet *applet)
+static GtkWidget *nma_context_menu_create (NMApplet *applet, GtkMenuShell *menu)
 {
+#ifndef ENABLE_INDICATOR
 	GtkMenuShell *menu;
 	GtkWidget *menu_item;
+#endif
 	GtkWidget *image;
 	guint id;
 
 	g_return_val_if_fail (applet != NULL, NULL);
 
+#ifndef ENABLE_INDICATOR
 	menu = GTK_MENU_SHELL (gtk_menu_new ());
+#endif
 
 	/* 'Enable Networking' item */
 	applet->networking_enabled_item = gtk_check_menu_item_new_with_mnemonic (_("Enable _Networking"));
@@ -2234,6 +2298,7 @@ static GtkWidget *nma_context_menu_creat
 
 	nma_menu_add_separator_item (GTK_WIDGET (menu));
 
+#ifndef ENABLE_INDICATOR
 	/* Toggle notifications item */
 	applet->notifications_enabled_item = gtk_check_menu_item_new_with_mnemonic (_("Enable N_otifications"));
 	id = g_signal_connect (applet->notifications_enabled_item,
@@ -2244,6 +2309,7 @@ static GtkWidget *nma_context_menu_creat
 	gtk_menu_shell_append (menu, applet->notifications_enabled_item);
 
 	nma_menu_add_separator_item (GTK_WIDGET (menu));
+#endif /* ENABLE_INDICATOR */
 
 	/* 'Connection Information' item */
 	applet->info_menu_item = gtk_image_menu_item_new_with_mnemonic (_("Connection _Information"));
@@ -2265,6 +2331,7 @@ static GtkWidget *nma_context_menu_creat
 	gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (applet->connections_menu_item), image);
 	gtk_menu_shell_append (menu, applet->connections_menu_item);
 
+#ifndef ENABLE_INDICATOR
 	/* Separator */
 	nma_menu_add_separator_item (GTK_WIDGET (menu));
 
@@ -2284,12 +2351,53 @@ static GtkWidget *nma_context_menu_creat
 	image = gtk_image_new_from_stock (GTK_STOCK_ABOUT, GTK_ICON_SIZE_MENU);
 	gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (menu_item), image);
 	gtk_menu_shell_append (menu, menu_item);
+#endif /* ENABLE_INDICATOR */
 
 	gtk_widget_show_all (GTK_WIDGET (menu));
 
 	return GTK_WIDGET (menu);
 }
 
+#ifdef ENABLE_INDICATOR
+static void
+indicator_update_menu (NMApplet *applet)
+{
+	if (!applet->in_fallback) {
+		if (applet->menu)
+			g_object_unref (applet->menu);
+
+		applet->menu = gtk_menu_new ();
+		g_object_ref_sink (G_OBJECT (applet->menu));
+		nma_menu_show_cb (applet->menu, applet);
+		nma_menu_add_separator_item (applet->menu);
+		applet->menu = nma_context_menu_create (applet, GTK_MENU_SHELL(applet->menu));
+
+		app_indicator_set_menu (applet->app_indicator, GTK_MENU (applet->menu));
+
+		nma_context_menu_update (applet);
+	}
+
+	applet->update_menu_id = 0;
+}
+
+static gboolean
+applet_update_indicator_menu (gpointer user_data)
+{
+	NMApplet *applet = NM_APPLET (user_data);
+
+	indicator_update_menu (applet);
+
+	return FALSE;
+}
+
+void
+applet_schedule_update_menu (NMApplet *applet)
+{
+	if (!applet->update_menu_id)
+		applet->update_menu_id = g_idle_add (applet_update_indicator_menu, applet);
+}
+#endif /* ENABLE_INDICATOR */
+
 typedef struct {
 	NMApplet *applet;
 	NMDevice *device;
@@ -2390,12 +2498,54 @@ applet_add_default_connection_item (NMDe
 /*****************************************************************************/
 
 static void
-foo_set_icon (NMApplet *applet, guint32 layer, GdkPixbuf *pixbuf, char *icon_name)
+foo_set_icon (NMApplet *applet, guint32 layer, GdkPixbuf *pixbuf, char *icon_name, char *new_tip)
 {
+	GString *tip = NULL;
 	int i;
 
 	g_return_if_fail (layer == ICON_LAYER_LINK || layer == ICON_LAYER_VPN);
 
+	switch (layer) {
+		case ICON_LAYER_LINK:
+			if (new_tip == NULL)
+				new_tip = g_strdup (_("No network connection"));
+			tip = g_string_new (new_tip);
+			break;
+		case ICON_LAYER_VPN:
+			tip = g_string_new (applet->tip);
+
+			if (new_tip)
+				g_string_append_printf (tip, "%s%s", tip->len ? "\n" : "", new_tip);
+			break;
+		default:
+			tip = g_string_new ("");
+			if (layer > ICON_LAYER_MAX) {
+				g_string_free (tip, TRUE);
+				g_warning ("Tried to icon to invalid layer %d", layer);
+				return;
+			}
+			break;
+	}
+
+	if (tip->len) {
+		g_free (applet->tip);
+		applet->tip = tip->str;
+	}
+
+	g_free (new_tip);
+	g_string_free (tip, FALSE);
+
+#ifdef ENABLE_INDICATOR
+	if (icon_name == NULL && layer == ICON_LAYER_LINK) {
+		icon_name = "nm-no-connection";
+	}
+
+	if (icon_name != NULL &&
+	    g_strcmp0 (app_indicator_get_icon (applet->app_indicator), icon_name) != 0) {
+		app_indicator_set_icon_full (applet->app_indicator, icon_name, applet->tip);
+	}
+#endif /* ENABLE_INDICATOR */
+
 	/* Ignore setting of the same icon as is already displayed */
 	if (applet->icon_layers[layer] == pixbuf)
 		return;
@@ -2428,6 +2578,11 @@ foo_set_icon (NMApplet *applet, guint32
 
 	gtk_status_icon_set_from_pixbuf (applet->status_icon, pixbuf);
 	g_object_unref (pixbuf);
+#if GTK_CHECK_VERSION(2, 15, 0)
+	gtk_status_icon_set_tooltip_text (applet->status_icon, applet->tip);
+#else
+	gtk_status_icon_set_tooltip (applet->status_icon, applet->tip);
+#endif
 }
 
 NMRemoteConnection *
@@ -2641,6 +2796,7 @@ foo_device_state_changed_cb (NMDevice *d
 	}
 
 	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
 static void
@@ -2697,8 +2853,20 @@ foo_client_state_changed_cb (NMClient *c
 	}
 
 	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
+#ifdef ENABLE_INDICATOR
+static void
+foo_device_removed_cb (NMClient *client, NMDevice *device, gpointer user_data)
+{
+	NMApplet *applet = NM_APPLET (user_data);
+
+	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
+}
+#endif
+
 static void
 foo_manager_running_cb (NMClient *client,
                         GParamSpec *pspec,
@@ -2714,6 +2882,7 @@ foo_manager_running_cb (NMClient *client
 	}
 
 	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
 #define VPN_STATE_ID_TAG "vpn-state-id"
@@ -2743,6 +2912,7 @@ foo_active_connections_changed_cb (NMCli
 	}
 
 	applet_schedule_update_icon (applet);
+	applet_schedule_update_menu (applet);
 }
 
 static void
@@ -2775,6 +2945,9 @@ foo_set_initial_state (gpointer data)
 	return FALSE;
 }
 
+static gboolean setup_widgets (NMApplet *applet);
+static void nma_icons_init (NMApplet *applet);
+
 static void
 foo_client_setup (NMApplet *applet)
 {
@@ -2793,6 +2966,11 @@ foo_client_setup (NMApplet *applet)
 	g_signal_connect (applet->nm_client, "device-added",
 	                  G_CALLBACK (foo_device_added_cb),
 	                  applet);
+#ifdef ENABLE_INDICATOR
+	g_signal_connect (applet->nm_client, "device-removed",
+	                  G_CALLBACK (foo_device_removed_cb),
+	                  applet);
+#endif /* ENABLE_INDICATOR */
 	g_signal_connect (applet->nm_client, "notify::manager-running",
 	                  G_CALLBACK (foo_manager_running_cb),
 	                  applet);
@@ -3065,7 +3243,19 @@ applet_update_icon (gpointer user_data)
 	if (!nm_running)
 		state = NM_STATE_UNKNOWN;
 
+#ifdef ENABLE_INDICATOR
+	if (applet->in_fallback)
+		gtk_status_icon_set_visible (applet->status_icon, applet->visible);
+	else
+		gtk_status_icon_set_visible (applet->status_icon, FALSE);
+
+	if (nm_running && applet->visible)
+		app_indicator_set_status (applet->app_indicator, APP_INDICATOR_STATUS_ACTIVE);
+	else
+		app_indicator_set_status (applet->app_indicator, APP_INDICATOR_STATUS_PASSIVE);
+#else
 	gtk_status_icon_set_visible (applet->status_icon, applet->visible);
+#endif
 
 	switch (state) {
 	case NM_STATE_UNKNOWN:
@@ -3084,7 +3274,7 @@ applet_update_icon (gpointer user_data)
 		break;
 	}
 
-	foo_set_icon (applet, ICON_LAYER_LINK, pixbuf, icon_name);
+	foo_set_icon (applet, ICON_LAYER_LINK, pixbuf, icon_name, g_strdup (dev_tip));
 	if (pixbuf)
 		g_object_unref (pixbuf);
 	if (icon_name)
@@ -3099,7 +3289,11 @@ applet_update_icon (gpointer user_data)
 
 		switch (vpn_state) {
 		case NM_VPN_CONNECTION_STATE_ACTIVATED:
+#ifndef ENABLE_INDICATOR
 			icon_name = g_strdup_printf ("nm-vpn-active-lock");
+#else
+			icon_name = g_strdup_printf ("%s-secure", app_indicator_get_icon (applet->app_indicator));
+#endif /* ENABLE_INDICATOR */
 			pixbuf = nma_icon_check_and_load (icon_name, applet);
 			break;
 		case NM_VPN_CONNECTION_STATE_PREPARE:
@@ -3127,7 +3321,7 @@ applet_update_icon (gpointer user_data)
 			vpn_tip = tmp;
 		}
 	}
-	foo_set_icon (applet, ICON_LAYER_VPN, pixbuf, icon_name);
+	foo_set_icon (applet, ICON_LAYER_VPN, pixbuf, icon_name, g_strdup (dev_tip));
 	if (icon_name)
 		g_free (icon_name);
 
@@ -3576,18 +3770,95 @@ status_icon_popup_menu_cb (GtkStatusIcon
 	 * of the notification. 
 	 */
 
+	/* Kill the old menu */
+	if (applet->context_menu)
+		g_object_unref (applet->context_menu);
+
+	/* And make a fresh new one */
+	applet->context_menu = gtk_menu_new ();
+	g_object_ref_sink (G_OBJECT (applet->context_menu));
+	applet->context_menu = nma_context_menu_create (applet, GTK_MENU_SHELL (applet->context_menu));
 	nma_context_menu_update (applet);
 	gtk_menu_popup (GTK_MENU (applet->context_menu), NULL, NULL,
 			gtk_status_icon_position_menu, icon,
 			button, activate_time);
 }
 
+#ifdef ENABLE_INDICATOR
+static GtkStatusIcon *
+indicator_fallback (AppIndicator *indicator)
+{
+	NMApplet *applet;
+
+	applet = NM_APPLET(g_object_get_data (G_OBJECT (indicator), "applet"));
+	g_return_val_if_fail (NM_IS_APPLET (applet), NULL);
+	g_return_val_if_fail (applet->status_icon, NULL);
+
+	g_message ("using fallback from indicator to GtkStatusIcon");
+	gtk_status_icon_set_visible (applet->status_icon, applet->visible);
+
+	applet->in_fallback = TRUE;
+
+	return applet->status_icon;
+}
+
+static void
+indicator_unfallback (AppIndicator *indicator, GtkStatusIcon *status_icon)
+{
+	NMApplet *applet;
+
+	applet = NM_APPLET(g_object_get_data (G_OBJECT (indicator), "applet"));
+	g_return_if_fail (NM_IS_APPLET (applet));
+	g_return_if_fail (applet->status_icon);
+
+	g_message ("moving back from GtkStatusIcon to indicator");
+	gtk_status_icon_set_visible (applet->status_icon, FALSE);
+
+	applet->in_fallback = FALSE;
+}
+
 static gboolean
-setup_widgets (NMApplet *applet)
+setup_indicator_menu (NMApplet *applet)
+{
+	g_return_val_if_fail (NM_IS_APPLET (applet), FALSE);
+
+	applet->in_fallback = FALSE;
+
+	applet->app_indicator = app_indicator_new
+				("nm-applet", "nm-no-connection",
+				 APP_INDICATOR_CATEGORY_SYSTEM_SERVICES);
+
+	app_indicator_set_title(applet->app_indicator, _("Network"));
+
+	g_object_set_data (G_OBJECT (applet->app_indicator), "applet", (gpointer) applet);
+
+	APP_INDICATOR_GET_CLASS(applet->app_indicator)->fallback = indicator_fallback;
+	APP_INDICATOR_GET_CLASS(applet->app_indicator)->unfallback = indicator_unfallback;
+
+	applet->menu = gtk_menu_new ();
+
+	g_object_ref_sink (G_OBJECT (applet->menu));
+
+	applet->menu = nma_context_menu_create (applet, GTK_MENU_SHELL(applet->menu));
+	nma_context_menu_update(applet);
+
+	app_indicator_set_menu(applet->app_indicator, GTK_MENU(applet->menu));
+
+	return TRUE;
+}
+#endif /* ENABLE_INDICATOR */
+
+static gboolean
+setup_statusicon_menu (NMApplet *applet)
 {
 	g_return_val_if_fail (NM_IS_APPLET (applet), FALSE);
 
 	applet->status_icon = gtk_status_icon_new ();
+
+#ifdef ENABLE_INDICATOR
+	gtk_status_icon_set_visible (applet->status_icon, FALSE);
+#endif
+
 	if (!applet->status_icon)
 		return FALSE;
 	if (shell_debug)
@@ -3602,13 +3873,36 @@ setup_widgets (NMApplet *applet)
 	g_signal_connect (applet->status_icon, "popup-menu",
 			  G_CALLBACK (status_icon_popup_menu_cb), applet);
 
-	applet->context_menu = nma_context_menu_create (applet);
-	if (!applet->context_menu)
-		return FALSE;
+	applet->context_menu = gtk_menu_new ();
+	applet->context_menu = nma_context_menu_create (applet, GTK_MENU_SHELL (applet->context_menu));
+	g_object_ref_sink (G_OBJECT (applet->context_menu));
+ 	if (!applet->context_menu)
+ 		return FALSE;
 
 	return TRUE;
 }
 
+static gboolean
+setup_widgets (NMApplet *applet)
+{
+	gboolean success = FALSE;
+	gboolean indicator_success = FALSE;
+
+	g_return_val_if_fail (NM_IS_APPLET (applet), FALSE);
+
+	success = setup_statusicon_menu (applet);
+
+#ifdef ENABLE_INDICATOR
+	indicator_success = setup_indicator_menu (applet);
+#endif
+
+#ifndef ENABLE_INDICATOR
+	return success;
+#else
+	return success || indicator_success;
+#endif
+}
+
 static void
 applet_embedded_cb (GObject *object, GParamSpec *pspec, gpointer user_data)
 {
@@ -3697,6 +3991,8 @@ initable_init (GInitable *initable, GCan
 	                  G_CALLBACK (applet_gsettings_show_changed), applet);
 
 
+	foo_client_setup (applet);
+
 	/* Load pixmaps and create applet widgets */
 	if (!setup_widgets (applet)) {
 		g_set_error_literal (error, NMA_ERROR, NMA_ERROR_GENERIC,
@@ -3775,8 +4071,6 @@ initable_init (GInitable *initable, GCan
 	applet->infiniband_class = applet_device_infiniband_get_class (applet);
 	g_assert (applet->infiniband_class);
 
-	foo_client_setup (applet);
-
 #if WITH_MODEM_MANAGER_1
 	mm1_client_setup (applet);
 #endif
@@ -3815,6 +4109,11 @@ static void finalize (GObject *object)
 	if (applet->update_icon_id)
 		g_source_remove (applet->update_icon_id);
 
+#ifdef ENABLE_INDICATOR
+	if (applet->update_menu_id)
+		g_source_remove (applet->update_menu_id);
+#endif /* ENABLE_INDICATOR */
+
 	if (applet->menu)
 		g_object_unref (applet->menu);
 	g_clear_pointer (&applet->icon_cache, g_hash_table_destroy);
@@ -3839,6 +4138,14 @@ static void finalize (GObject *object)
 	if (applet->status_icon)
 		g_object_unref (applet->status_icon);
 
+#ifdef ENABLE_INDICATOR
+	if (applet->app_indicator)
+	{
+		APP_INDICATOR_GET_CLASS(applet->app_indicator)->unfallback = NULL;
+		g_object_unref (applet->app_indicator);
+	}
+#endif
+
 	if (applet->nm_client)
 		g_object_unref (applet->nm_client);
 
Index: network-manager-applet-1.0.4/src/applet.h
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet.h
+++ network-manager-applet-1.0.4/src/applet.h
@@ -36,6 +36,10 @@
 
 #include <libnotify/notify.h>
 
+#if ENABLE_INDICATOR
+#include <libappindicator/app-indicator.h>
+#endif
+
 #include <nm-connection.h>
 #include <nm-client.h>
 #include <nm-access-point.h>
@@ -135,6 +139,11 @@ typedef struct
 	guint			animation_id;
 
 	/* Direct UI elements */
+#if ENABLE_INDICATOR
+	AppIndicator *	app_indicator;
+	guint		update_menu_id;
+	gboolean	in_fallback;
+#endif
 	GtkStatusIcon * status_icon;
 	int             icon_size;
 
@@ -248,6 +257,10 @@ NMApplet *nm_applet_new (void);
 
 void applet_schedule_update_icon (NMApplet *applet);
 
+#if ENABLE_INDICATOR
+void applet_schedule_update_menu (NMApplet *applet);
+#endif /* ENABLE_INDICATOR */
+
 NMRemoteSettings *applet_get_settings (NMApplet *applet);
 
 GSList *applet_get_all_connections (NMApplet *applet);
Index: network-manager-applet-1.0.4/src/mobile-helpers.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/mobile-helpers.c
+++ network-manager-applet-1.0.4/src/mobile-helpers.c
@@ -44,7 +44,11 @@ mobile_helper_get_status_pixbuf (guint32
 
 	if (!quality_valid)
 		quality = 0;
+#ifndef ENABLE_INDICATOR
 	qual_pixbuf = nma_icon_check_and_load (mobile_helper_get_quality_icon_name (quality), applet);
+#else
+	qual_pixbuf = wwan_pixbuf;
+#endif
 
 	pixbuf = gdk_pixbuf_new (GDK_COLORSPACE_RGB,
 	                         TRUE,
@@ -102,6 +106,18 @@ mobile_helper_get_status_pixbuf (guint32
 const char *
 mobile_helper_get_quality_icon_name (guint32 quality)
 {
+#ifdef ENABLE_INDICATOR
+ 	if (quality > 80)
+		return "gsm-3g-full";
+ 	else if (quality > 55)
+		return "gsm-3g-high";
+ 	else if (quality > 30)
+		return "gsm-3g-medium";
+ 	else if (quality > 5)
+		return "gsm-3g-low";
+ 	else
+		return "gsm-3g-none";
+#else
 	if (quality > 80)
 		return "nm-signal-100";
 	else if (quality > 55)
@@ -112,7 +128,119 @@ mobile_helper_get_quality_icon_name (gui
 		return "nm-signal-25";
 	else 
 		return "nm-signal-00";
+#endif
 }
+#ifdef ENABLE_INDICATOR
+static const char *
+get_tech_name (guint32 tech)
+{
+	switch (tech) {
+	case MB_TECH_1XRTT:
+		return _("CDMA");
+	case MB_TECH_EVDO:
+		return _("EVDO");
+	case MB_TECH_GSM:
+		return _("GSM");
+	case MB_TECH_GPRS:
+		return _("GPRS");
+	case MB_TECH_EDGE:
+		return _("EDGE");
+	case MB_TECH_UMTS:
+		return _("UMTS");
+	case MB_TECH_HSDPA:
+		return _("HSDPA");
+	case MB_TECH_HSUPA:
+		return _("HSUPA");
+	case MB_TECH_HSPA:
+		return _("HSPA");
+	case MB_TECH_HSPA_PLUS:
+		return _("HSPA+");
+	case MB_TECH_LTE:
+		return _("LTE");
+	default:
+		break;
+	}
+	return NULL;
+}
+
+char *
+mobile_helper_get_connection_label (const char *connection_name,
+                                    const char *provider,
+                                    guint32 technology,
+                                    guint32 state)
+{
+	const char *tech_name;
+	char *desc_string;
+
+	/* Construct the description string */
+	tech_name = get_tech_name (technology);
+	switch (state) {
+	default:
+	case MB_STATE_UNKNOWN:
+		desc_string = g_strdup (_("not enabled"));
+		break;
+	case MB_STATE_IDLE:
+		if (connection_name)
+			desc_string = g_strdup (connection_name);
+		else
+			desc_string = g_strdup (_("not registered"));
+		break;
+	case MB_STATE_HOME:
+		if (connection_name) {
+			if (provider && tech_name)
+				desc_string = g_strdup_printf ("%s (%s %s)", connection_name, provider, tech_name);
+ 			else if (provider || tech_name)
+				desc_string = g_strdup_printf ("%s (%s)", connection_name, provider ? provider : tech_name);
+			else
+				desc_string = g_strdup_printf ("%s", connection_name);
+		} else {
+			if (provider) {
+				if (tech_name)
+					desc_string = g_strdup_printf ("%s %s", provider, tech_name);
+				else
+					desc_string = g_strdup_printf ("%s", provider);
+			} else {
+				if (tech_name)
+					desc_string = g_strdup_printf (_("Home network (%s)"), tech_name);
+				else
+					desc_string = g_strdup_printf (_("Home network"));
+			}
+		}
+		break;
+	case MB_STATE_SEARCHING:
+		if (connection_name)
+			desc_string = g_strdup (connection_name);
+		else
+			desc_string = g_strdup (_("searching"));
+		break;
+	case MB_STATE_DENIED:
+		desc_string = g_strdup (_("registration denied"));
+		break;
+	case MB_STATE_ROAMING:
+		if (connection_name) {
+			if (tech_name)
+				desc_string = g_strdup_printf (_("%s (%s roaming)"), connection_name, tech_name);
+			else
+				desc_string = g_strdup_printf (_("%s (roaming)"), connection_name);
+		} else {
+			if (provider) {
+				if (tech_name)
+					desc_string = g_strdup_printf (_("%s (%s roaming)"), provider, tech_name);
+				else
+					desc_string = g_strdup_printf (_("%s (roaming)"), provider);
+			} else {
+				if (tech_name)
+					desc_string = g_strdup_printf (_("Roaming network (%s)"), tech_name);
+				else
+					desc_string = g_strdup_printf (_("Roaming network"));
+			}
+		}
+		break;
+	}
+
+	return desc_string;
+}
+#endif
 
 const char *
 mobile_helper_get_tech_icon_name (guint32 tech)
@@ -606,6 +734,8 @@ mobile_helper_get_icon (NMDevice *device
 		                                               mb_state,
 		                                               mb_tech,
 		                                               applet);
+		*out_icon_name = mobile_helper_get_quality_icon_name (quality_valid ?
+		                                                      quality : 0);
 		if ((mb_state != MB_STATE_UNKNOWN) && quality_valid) {
 			gboolean roaming = (mb_state == MB_STATE_ROAMING);
 
Index: network-manager-applet-1.0.4/src/mobile-helpers.h
===================================================================
--- network-manager-applet-1.0.4.orig/src/mobile-helpers.h
+++ network-manager-applet-1.0.4/src/mobile-helpers.h
@@ -65,6 +65,13 @@ GdkPixbuf *mobile_helper_get_status_pixb
 const char *mobile_helper_get_quality_icon_name (guint32 quality);
 const char *mobile_helper_get_tech_icon_name (guint32 tech);
 
+#ifdef ENABLE_INDICATOR
+char *mobile_helper_get_connection_label (const char *connection_name,
+                                          const char *provider,
+                                          guint32 technology,
+                                          guint32 state);
+#endif
+
 /********************************************************************/
 
 gboolean   mobile_helper_wizard (NMDeviceModemCapabilities capabilities,
Index: network-manager-applet-1.0.4/src/mb-menu-item.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/mb-menu-item.c
+++ network-manager-applet-1.0.4/src/mb-menu-item.c
@@ -183,12 +183,15 @@ nm_mb_menu_item_new (const char *connect
 		gtk_label_set_text (GTK_LABEL (priv->desc), priv->desc_string);
 	}
 
+/* Disabling this for indicators only because it won't build otherwise. */
+#ifndef ENABLE_INDICATOR
 	/* And the strength icon, if we have strength information at all */
 	if (enabled && strength) {
 		GdkPixbuf *pixbuf = nma_icon_check_and_load (mobile_helper_get_quality_icon_name (strength), applet);
 
 		gtk_image_set_from_pixbuf (GTK_IMAGE (priv->strength), pixbuf);
 	}
+#endif
 
 	return GTK_WIDGET (item);
 }
Index: network-manager-applet-1.0.4/src/gconf-helpers/Makefile.am
===================================================================
--- network-manager-applet-1.0.4.orig/src/gconf-helpers/Makefile.am
+++ network-manager-applet-1.0.4/src/gconf-helpers/Makefile.am
@@ -16,6 +16,7 @@ libgconf_helpers_la_CPPFLAGS = \
 	-I$(top_srcdir)/src/utils \
 	$(GTK_CFLAGS) \
 	$(NMA_CFLAGS) \
+	$(APPINDICATOR_CFLAGS) \
 	$(MIGRATION_CFLAGS) \
 	$(DISABLE_DEPRECATED)
 
@@ -34,6 +35,7 @@ libgconf_helpers_test_la_CPPFLAGS = \
 	-I$(top_srcdir)/src/utils \
 	$(GTK_CFLAGS) \
 	$(NMA_CFLAGS) \
+	$(APPINDICATOR_CFLAGS) \
 	$(MIGRATION_CFLAGS) \
 	$(DISABLE_DEPRECATED)
 
Index: network-manager-applet-1.0.4/src/applet-device-wimax.c
===================================================================
--- network-manager-applet-1.0.4.orig/src/applet-device-wimax.c
+++ network-manager-applet-1.0.4/src/applet-device-wimax.c
@@ -36,6 +36,7 @@
 #include "applet.h"
 #include "applet-device-wimax.h"
 #include "applet-dialogs.h"
+#include "mobile-helpers.h"
 #include "nma-marshal.h"
 #include "mb-menu-item.h"
 #include "nm-ui-utils.h"
@@ -141,9 +142,15 @@ new_nsp_menu_item (NMDeviceWimax *device
 {
 	GtkWidget *item;
 	WimaxMenuItemInfo *info;
+#ifdef ENABLE_INDICATOR
+	char *text = NULL;
+	const char *icon_name;
+	GtkWidget *signal_icon = NULL;
+#endif
 
 	g_return_val_if_fail (nsp != NULL, NULL);
 
+#ifndef ENABLE_INDICATOR
 	item = nm_mb_menu_item_new (nm_wimax_nsp_get_name (nsp),
 		                        nm_wimax_nsp_get_signal_quality (nsp),
 		                        NULL,
@@ -152,6 +159,15 @@ new_nsp_menu_item (NMDeviceWimax *device
 		                        nsp_type_to_mb_state (nm_wimax_nsp_get_network_type (nsp)),
 		                        TRUE,
 		                        applet);
+#else
+	text = g_strdup (nm_wimax_nsp_get_name (nsp));
+	item = gtk_image_menu_item_new_with_label (text);
+	g_free (text);
+	icon_name = mobile_helper_get_quality_icon_name (nm_wimax_nsp_get_signal_quality (nsp));
+	signal_icon = gtk_image_new_from_icon_name (icon_name, GTK_ICON_SIZE_LARGE_TOOLBAR);
+	gtk_image_menu_item_set_image (GTK_IMAGE_MENU_ITEM (item), signal_icon);
+	gtk_image_menu_item_set_always_show_image (GTK_IMAGE_MENU_ITEM (item), TRUE);
+#endif /* ENABLE_INDICATOR */
 	gtk_widget_set_sensitive (GTK_WIDGET (item), TRUE);
 
 	info = g_slice_new0 (WimaxMenuItemInfo);
@@ -296,7 +312,12 @@ wimax_add_menu_item (NMDevice *device,
 static void
 nsp_quality_changed (NMWimaxNsp *nsp, GParamSpec *pspec, gpointer user_data)
 {
-	applet_schedule_update_icon (NM_APPLET (user_data));
+	NMApplet *applet = NM_APPLET (user_data);
+
+	applet_schedule_update_icon (applet);
+#ifdef ENABLE_INDICATOR
+	applet_schedule_update_menu (applet);
+#endif /* ENABLE_INDICATOR */
 }
 
 static NMWimaxNsp *
@@ -358,8 +379,12 @@ active_nsp_changed_cb (NMDeviceWimax *de
 	if (!s_wimax)
 		return;
 
-	if (g_strcmp0 (nm_wimax_nsp_get_name (new), nm_setting_wimax_get_network_name (s_wimax)) != 0)
+	if (g_strcmp0 (nm_wimax_nsp_get_name (new), nm_setting_wimax_get_network_name (s_wimax)) != 0) {
 		applet_schedule_update_icon (applet);
+#ifdef ENABLE_INDICATOR
+		applet_schedule_update_menu (applet);
+#endif /* ENABLE_INDICATOR */
+	}
 }
 
 static void
@@ -375,6 +400,9 @@ nsp_removed_cb (NMDeviceWimax *device,
 	if (old == nsp) {
 		g_object_set_data (G_OBJECT (device), ACTIVE_NSP_TAG, NULL);
 		applet_schedule_update_icon (applet);
+#ifdef ENABLE_INDICATOR
+		applet_schedule_update_menu (applet);
+#endif /* ENABLE_INDICATOR */
 	}
 }
 
